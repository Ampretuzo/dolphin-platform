<link rel="import" href="../bower_components/polymer/polymer.html">
<script src="../bower_components/raphael/raphael.js"></script>
<script src="../bower_components/jquery/dist/jquery.min.js"></script>
<script src="../bower_components/graphdracula/lib/dracula_graffle.js"></script>
<script src="../bower_components/graphdracula/lib/dracula_graph.js"></script>
<script src="../bower_components/graphdracula/lib/dracula_algorithms.js"></script>

<polymer-element name="workflow-canvas" attributes="data">
    <template>
        <div id="flowchart"></div>
    </template>
    <script>
        Polymer({
            dataChanged: function(oldValue, newValue) {
                console.log("processInstance changed", newValue);

                var host = this.$.flowchart;

                var width = 600;
                var height = 400;

                var g = new Graph();

                /* add a simple node */
                g.addNode("strawberry");
                g.addNode("cherry");

                /* add a node with a customized label */
                g.addNode("1", { label : "Tomato" });


                /* add a node with a customized shape
                 (the Raphael graph drawing implementation can draw this shape, please
                 consult the RaphaelJS reference for details http://raphaeljs.com/) */
                var render = function(r, n) {
                    var label = r.text(0, 30, n.label).attr({opacity:0});
                    //the Raphael set is obligatory, containing all you want to display
                    var set = r.set()
                            .push(r.rect(-30, -13, 62, 86)
                                    .attr({ fill: '#fa8', 'stroke-width': 2, r: 9 })
                    )
                            .push(label);

                    // make the label show only on hover
                    set.hover(
                            function mouseIn() {
                                label.animate({ opacity: 1, 'fill-opacity': 1 }, 500);
                            },
                            function mouseOut() {
                                label.animate({opacity:0},300);
                            }
                    );

                    var tooltip = r.set()
                            .push(
                            r.rect(0, 0, 90, 30).attr({ fill: '#fec', 'stroke-width': 1, r: 9 })
                    ).push(
                            r.text(25, 15, 'overlay').attr({ fill: '#000000' })
                    );
                    for(var i in set.items) {
                        set.items[i].tooltip(tooltip);
                    }
                    //            set.tooltip(r.set().push(r.rect(0, 0, 30, 30).attr({"fill": "#fec", "stroke-width": 1, r : "9px"})).hide());
                    return set;
                };

                g.addNode('id35', {
                    label: "meat\nand\ngreed",
                    /* filling the shape with a color makes it easier to be dragged */
                    /* arguments: r = Raphael object, n : node object */
                    render: render
                });
                //    g.addNode("Wheat", {
                /* filling the shape with a color makes it easier to be dragged */
                /* arguments: r = Raphael object, n : node object */
                //        shapes : [ {
                //                type: "rect",
                //                x: 10,
                //                y: 10,
                //                width: 25,
                //                height: 25,
                //                stroke: "#f00"
                //            }, {
                //                type: "text",
                //                x: 30,
                //                y: 40,
                //                text: "Dump"
                //            }],
                //        overlay : "<b>Hello <a href=\"http://wikipedia.org/\">World!</a></b>"
                //    });

                var st = {
                    directed: true,
                    label: 'Label',
                    'label-style' : {
                        'font-size': 20
                    }
                };
                g.addEdge('kiwi', 'penguin', st);

                /* connect nodes with edges */
                g.addEdge('strawberry', 'cherry', {directed: true});
                g.addEdge('cherry', 'apple');
                g.addEdge('cherry', 'apple');
                g.addEdge('1', 'id35');
                g.addEdge('penguin', 'id35');
                g.addEdge('penguin', 'apple');
                g.addEdge('kiwi', 'id35');

                /* a directed connection, using an arrow */
                g.addEdge('1', 'cherry', { directed: true } );

                /* customize the colors of that edge */
                g.addEdge('id35', 'apple', { stroke: '#bfa' , fill: '#56f', label: 'Meat-to-Apple' });

                /* add an unknown node implicitly by adding an edge */
                g.addEdge('strawberry', 'apple');

                //g.removeNode("1");

                /* layout the graph using the Spring layout implementation */
                var layouter = new Graph.Layout.Spring(g);

                /* draw the graph using the RaphaelJS draw implementation */
                var renderer = new Graph.Renderer.Raphael(host, g, width, height);

                redraw = function() {
                    layouter.layout();
                    renderer.draw();
                };
                hide = function(id) {
                    g.nodes[id].hide();
                };
                show = function(id) {
                    g.nodes[id].show();
                };
                //    console.log(g.nodes["kiwi"]);
                //redraw();





//                var text = 'graph LR\n';
////                newValue.activities.forEach(function(activity) {
////                    text += 'A' + activity.label + '[' + activity.label + ']\n';
////                });
////                newValue.activities.forEach(function(activity) {
////                    text +=  'A' + newValue.startActivity.label + ' --> A' + activity.label + '\n';
////                });
//
//
////                text += 'Start[Start] --> Start\n';
////
////                newValue.activities.forEach(function(activity, index) {
////                    text +=  'Start' + ' --> A' + index + '[A' + index + ']\n';
////                });
//
//                text += 'A[Square Rect] -- Link text --> B((Circle))\n';
//                text += 'A --> C(Round Rect)\n';
//                text += 'B --> D{Rhombus}\n';
//                text += 'C --> D\n';
//
//                var node = document.createElement('div');
//                node.classList.add('mermaid');
//                node.textContent = text;
//
//                var host = this.$.flowchart;
//                if (typeof host.firstChild !== 'undefined' && host.firstChild !== null) {
//                    host.removeChild(host.firstChild);
//                }
//                host.appendChild(node);
//
//                console.log("Result 1", mermaid.parse("graph LR\nA[Square Rect] -- Link text --> B((Circle))\nA --> C(Round Rect)\nB --> D{Rhombus}\nC --> D"));
//                console.log("Result 2", mermaid.parse(text));
//
//                mermaid.init(node);
            }
        })
    </script>
</polymer-element>